{
    "contents" : "# This version of the code checks new angle and two angles from v1 and v2 for angle criterian.\n\n# Various Required Functions\n\n'%!in%' <- function(x,y)!('%in%'(x,y))\n\ncrossvec <- function(x,y){\n  if(length(x)!=2 |length(y)!=2) stop('bad vectors')\n  cv <-  x[1]*y[2]-x[2]*y[1]\n  return(cv)\n}\n\ndistance <- function (v1,v2){\n  v12=v1-v2\n  mag=sqrt(v12[1]*v12[1]+v12[2]*v12[2])\n  return ( mag )\n}\n\nInsideTriangle <- function(verts,P){\n  \n  v1=matrix(verts[1, ],1,2)\n  v2=matrix(verts[2, ],1,2)\n  v3=matrix(verts[3, ],1,2)\n  \n  v12=v1-v2\n  v23=v2-v3\n  v31=v3-v1\n  \n  v1p=v1-P\n  v2p=v2-P\n  v3p=v3-P\n  \n  \n  c1=crossvec(v1p,v12)\n  c2=crossvec(v2p,v23)\n  c3=crossvec(v3p,v31)\n  \n  if((c1>0 && c2>0 && c3>0) || (c1<0 && c2<0 && c3<0)){\n    result=TRUE\n  } else { result = FALSE}\n  return(result)\n  \n}\n\ntheta <- function(a,b){\n  if( crossvec(a,b) < 0){\n    temp=a\n    a=b\n    b=temp\n    rm(\"temp\")\n  }\n  \n  theta=acos(sum(a*b)/\n               (sqrt(a[1]*a[1]+a[2]*a[2])*sqrt(b[1]*b[1]+b[2]*b[2])))\n  return( theta )\n}\n\nlogit <- function(a){\n  value=exp(a)/(exp(a)+1)\n  return( value )\n}\n\norient <- function(p,q,r){\n  int=(q[2] - p[2]) * (r[1] - q[1]) -\n    (q[1] - p[1]) * (r[2] - q[2]);\n  \n  return( sign(int) )\n}\n\nonSegment <- function(p, q, r){\n  status = FALSE\n  if (q[1] <= max(p[1], r[1]) && q[1] >= min(p[1], r[1]) &&\n        q[2] <= max(p[2], r[2]) && q[2] >= min(p[2], r[2])) status = TRUE\n  return ( status )\n}\n\ndoIntersect<- function(special=F,p1, q1, p2, q2){\n  \n  status = FALSE\n\n  o1 = orient(p1, q1, p2);\n  o2 = orient(p1, q1, q2);\n  o3 = orient(p2, q2, p1);\n  o4 = orient(p2, q2, q1);\n  \n  #general case\n  if (o1 != o2 && o3 != o4) status = TRUE\n  \n  if(special){\n    # Special Cases\n    # p1, q1 and p2 are colinear and p2 lies on segment p1q1\n    if (o1 == 0 && onSegment(p1, p2, q1)) status = TRUE\n    \n    # p1, q1 and p2 are colinear and q2 lies on segment p1q1\n    if (o2 == 0 && onSegment(p1, q2, q1)) status = TRUE\n    \n    # p2, q2 and p1 are colinear and p1 lies on segment p2q2\n    if (o3 == 0 && onSegment(p2, p1, q2)) status = TRUE\n    \n    # p2, q2 and q1 are colinear and q1 lies on segment p2q2\n    if (o4 == 0 && onSegment(p2, q1, q2)) status = TRUE\n  }\n  return (status)\n}\n\n# Example test of InsideTriangle\n# set.seed(1000)\n# X <- matrix(stats::rnorm(2000), ncol = 2)\n# hpts <- chull(X)\n# plot(X, cex = 0.5)\n# polygon(X[hpts, ])\n# \n# tri=X[hpts[c(4,5,1)], ]\n# polygon(tri,col=rgb(100,0,0,35,maxColorValue=100))\n# green.pt=matrix(X[315,],ncol=2)\n# blue.pt=matrix(X[784,],ncol=2)\n# v1=matrix(X[hpts[4], ],1,2)\n# v2=matrix(X[hpts[5], ],1,2)\n# v3=matrix(X[hpts[1], ],1,2)\n# \n# points(blue.pt,pch=8,col=\"blue\")\n# points(green.pt,pch=8,col=\"green\")\n# \n# text(v1,\"v1\")\n# text(v2,\"v2\")\n# text(v3,\"v3\")\n# InsideTriangle(verts=tri,P=blue.pt)\n# InsideTriangle(verts=tri,P=green.pt)\n\nbow.factor=75*pi/180\nset.seed(1500)\nX <- matrix(c(stats::rnorm(500),stats::rnorm(200)), ncol = 2)\n\nShrinkWrap <- function(X, bow.factor){\n  hpts <- chull(X)\n  plot(X, cex = 0.5, main=paste(\"Bow angle:\",bow.factor*180/pi,\" - Sample data.\"))\n  polygon(X[hpts, ])\n  X[hpts, ]\n  outline=hpts\n  \n  q=1\n  repeat{\n    if(q > (length(outline))) break\n    \n    v1=matrix(X[outline[q], ],1,2)\n    if(q == length(outline)){\n      v2=matrix(X[outline[1], ],1,2)\n    }\n    if(q != length(outline)){\n      v2=matrix(X[outline[q+1], ],1,2)\n    }  \n    check.vec=T\n    dist.matrix=NULL\n    for( ii in 1:dim(X)[1]){\n      v3=matrix(X[ii, ],1,2)\n      dist.matrix$distance[ii]=distance(v1=v1,v2=v3)\n      dist.matrix$ID[ii]=ii\n    }\n    # Check the points in order of distance, adds - code will add closest point\n    # to v1 that satisfies test(s).\n    cand=order(dist.matrix$distance)[order(dist.matrix$distance) %!in% outline]\n    point.check=FALSE\n    itt=1\n    \n    repeat{\n      \n      if (point.check == TRUE) { break }\n      if (itt > length(cand)) { break }\n      \n      status.exclude=FALSE\n      repeat{\n        # In this repeat loop, I check to see if adding the new point to the outline\n        # will exclude any point from the polygon created.\n        v3=matrix(X[cand[itt], ],1,2)\n        check.vec=T\n        verts=t(matrix(c(v1,v2,v3),2,3))\n        if (status.exclude == TRUE) break\n        for (mm in 1:dim(X)[1]){\n          check.vec[mm]=T\n          check.vec[mm]=InsideTriangle(verts=verts,P=matrix(X[mm, ],1,2))\n        }\n        if (length(check.vec [ check.vec == TRUE]) == 0) {status.exclude=TRUE}\n        else {\n          itt=itt+1\n          if (itt > length(cand)) { break }\n        }\n      }\n      if (itt > length(cand)) { break }\n      status.theta=FALSE\n      repeat{\n        # This repeat loop checks the new angles created by adding the point to see\n        # if the new angles are less than a chosen angle.\n        if(status.theta == TRUE) break\n        v3=matrix(X[cand[itt], ],1,2)\n        \n        if(q == length(outline)){\n          v2a=matrix(X[outline[2], ],1,2)\n          v1b=matrix(X[outline[q-1], ],1,2)\n        }\n        if(q == length(outline)-1){\n          v2a=matrix(X[outline[1], ],1,2)\n          v1b=matrix(X[outline[q-1], ],1,2)\n        }\n        \n        if(q == 1){\n          v2a=matrix(X[outline[q+2], ],1,2)\n          v1b=matrix(X[outline[length(outline)], ],1,2)\n        }\n        if(q != 1 & q!= length(outline) & q!= length(outline)-1){\n          v1b=matrix(X[outline[q-1], ],1,2)\n          v2a=matrix(X[outline[q+2], ],1,2)\n        }\n        v1p=v1-v3\n        v2p=v2-v3\n        \n        vb1=-(v1b-v1)\n        \n        va2=v2-v2a\n        \n        \n        theta.ang=theta(v1p,v2p)\n        theta.ang.a=theta(v2p,va2)\n        theta.ang.b=theta(v1p,vb1)\n        if (theta.ang >= bow.factor && theta.ang.b >= bow.factor && theta.ang.a >= bow.factor) {\n          status.theta=TRUE\n        }\n        else {\n          itt=itt+1\n          status.exclude=FALSE\n          if (itt > length(cand)) { break }\n        }\n      }\n      if (itt > length(cand)) { break }\n      \n      status.intersect=FALSE\n      repeat{\n        # This loop makes sure that the new lines created by adding this point\n        # will not intersect with any current line.\n        # Note: I was lazy and only checked one line.  I can think of scenarios where\n        # this will not be good enough, but in most cases it will be.  I thought I\n        # would cross that bridge when, and if, I got to it.\n        if(status.intersect == TRUE) break\n        for ( tt in 1:(length(outline)-1)){\n          s1=matrix(X[outline[tt], ],1,2)\n          if(tt==1){\n            s2=matrix(X[outline[length(outline)], ],1,2)\n          }\n          if(tt!=1){\n            s2=matrix(X[outline[tt+1], ],1,2)\n          }\n          s3=matrix(X[outline[q], ],1,2)\n          s4=matrix(X[cand[itt], ],1,2)\n          if(s1!=s2 && s1 != s3 && s1 != s4 && s2 !=s3 && s2 !=s4 && s3 != s4){\n            intersect = doIntersect(s1,s2,s3,s4,special=F)\n            if(intersect == TRUE) break\n          }\n        } \n        if(intersect == FALSE) {status.intersect = TRUE}\n        else{\n          itt=itt+1\n          status.theta=FALSE\n          if (itt > length(cand)) { break }\n        }\n      }\n      if (itt > length(cand)) { break }\n      if (status.intersect == TRUE && status.theta == TRUE && status.exclude == TRUE) {\n        point.check = TRUE\n      } else {\n        itt=itt+1\n      }\n    }\n    if (point.check == TRUE){\n      print(paste(\"Adding point ID:\",cand[itt]))\n      print(paste(\"Angles:\",\n                  paste(round(theta.ang*180/pi,2),\n                        round(theta.ang.a*180/pi,2),\n                        round(theta.ang.b*180/pi,2),\n                        sep=\",\")))\n      points(matrix(X[cand[itt], ],1,2), col=\"green\",pch=19,cex=0.5)\n      if (q != length(outline)){\n        outline=c(outline[seq(from=1,to=q)],\n                  cand[itt],outline[seq(from=q+1,to=length(outline))])\n      }\n      else {\n        outline=c(outline[seq(from=1,to=q)],\n                  cand[itt])\n      }\n      q=q-1\n    }\n    rm(\"cand\")\n    q=q+1\n  }\n  out.data=X[outline, ]\n  # This out data is suitable for the R polygon command, \n  # but in some cases you will need to repeat the first data point at the end\n  # in order to create the polygon.  The below commented command will do this.\n  #out.data=X[c(outline,outline[1]), ]\n  \n  \n  return (out.data)\n}\n\nOut.data=ShrinkWrap(X,bow.factor)\npolygon(Out.data,col=rgb(100,0,0,20,maxColorValue=100))\n\n\n\n\n\n",
    "created" : 1405956050383.000,
    "dirty" : false,
    "encoding" : "UTF-8",
    "folds" : "",
    "hash" : "301080714",
    "id" : "F32E84D1",
    "lastKnownWriteTime" : 1405022367,
    "path" : "~/MBA/R project (non Twitter)/ShrinkWrap/ShrinkWrap.R",
    "project_path" : null,
    "properties" : {
    },
    "source_on_save" : false,
    "type" : "r_source"
}